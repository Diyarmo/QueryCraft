## Assumptions & Scope Notes
- **Model availability**: The Ollama container can download and serve `sqlcoder-7b-2.Q4_K_M.gguf` without manual intervention; warm-up latency is acceptable for demo purposes.
- **Read-only SQL**: All generated SQL remains read-only (SELECT-only). DDL/DML statements such as INSERT/UPDATE/DELETE/DROP are out of scope and should be rejected.
- **Seed data volume**: Generating ≥1,000 Faker-driven rows across customers, products, and orders is sufficient to showcase realistic queries.
- **Single-tenant demo**: Authentication/authorization is not required for this MVP; assume all users share the same access.
- **Synchronous agent**: LangGraph workflow executes synchronously per request; no background queue or async worker is planned.
- **Local deployment**: Primary target is local docker-compose usage; production hardening (observability, autoscaling) is deferred unless noted otherwise.
- **Order status values**: `order.status` is constrained to `pending`, `completed`, `cancelled`, or `refunded` to keep reporting consistent.
- **Customer signup queries**: Time-bound signup analytics are common, so `customers.registration_date` and `orders.order_date` are indexed for fast aggregates.
- **Currency scale**: Product prices are stored as whole-number IRR amounts.
- **Order granularity**: Each `Order` represents a single product purchase (no header/line split) to keep the MVP schema and LangGraph prompts simple; multi-item carts would require introducing `OrderLine` records later if needed.
- **Agent trust**: The SQL executor still enforces single `SELECT` statements, but we allow harmless literals containing words like “insert” or “delete” under the assumption that LangGraph validation guarantees queries remain read-only.
- **Model language support**: We only guarantee English questions for now; Persian inputs will be tested for accuracy later, and we’ll insert a translation node if the model struggles.
- **Schema prompt maintenance**: The QuestionToSQL node uses a hardcoded schema reference rather than dynamically generating it from Django models. We experimented with auto-building the schema from model metadata but found it added unnecessary complexity for our relatively static schema. If the models begin changing frequently, we should revisit a dynamic schema generation strategy.
- **Execution failures**: If the generated SQL fails during execution, we surface the database error directly to the user instead of attempting retries with coder model or query repair.
- **Coder Model Temperature**: The coder model temperature is set to 0.0 because we don't want creativity and non-deterministi behavior at this stage. We can tweak its value later or make it configable attribute of the system. 
